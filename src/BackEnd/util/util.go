package util

import (
	"fmt"
	"log"
	"time"
)

var colorlist = []string{"#ce76fe", "#ed6f71", "#feae33", "#5358e2", "#fec46b"}

type Node struct {
	Id    int    `json:"id"`
	Level int    `json:"level"`
	Label string `json:"label"`
	Color string `json:"color"`
	Group int    `json:"group"`
}

type Edge struct {
	From int `json:"from"`
	To   int `json:"to"`
}

type ResponseAPI struct {
	Nodes   []Node        `json:"nodes"`
	Edges   []Edge        `json:"edges"`
	Status  bool          `json:"status"`
	Message string        `json:"message"`
	Time    time.Duration `json:"time"`
	Hit     int           `json:"hit"`
	Degree  int           `json:"degree"`
}

type Page struct {
	Title  string `json:"title"`
	Pageid int    `json:"pageid"`
	Url    string `json:"url"`
	Status bool   `json:"status"`
}

type AutoGenerated struct {
	Batchcomplete bool `json:"batchcomplete"`
	Continue      struct {
		Sroffset int    `json:"sroffset"`
		Continue string `json:"continue"`
	} `json:"continue"`
	Query struct {
		Searchinfo struct {
			Totalhits         int    `json:"totalhits"`
			Suggestion        string `json:"suggestion"`
			Suggestionsnippet string `json:"suggestionsnippet"`
		} `json:"searchinfo"`
		Search []struct {
			Ns        int       `json:"ns"`
			Title     string    `json:"title"`
			Pageid    int       `json:"pageid"`
			Size      int       `json:"size"`
			Wordcount int       `json:"wordcount"`
			Snippet   string    `json:"snippet"`
			Timestamp time.Time `json:"timestamp"`
		} `json:"search"`
	} `json:"query"`
}

func TimeTrack(start time.Time, name string, executedTime *time.Duration) {
	elapsed := time.Since(start)
	*executedTime = elapsed
	log.Printf("%s took %s", name, elapsed)

}

func ConvertToVisualizer(id *int, depth int, temp_nodes *[]Node, temp_edges *[]Edge, temp_visited map[string]int, graph map[string]map[string]bool, url string, start string, maxdepth int) bool {
	if url == start {
		// create edge
		return true
	}

	if depth > maxdepth {
		// fmt.Println(depth, " ", maxdepth, " - depth | max depth")
		return false
	}

	// fmt.Println("current url: ", url)
	// fmt.Println("current depth: ", depth)

	_, err := temp_visited[url]
	if !err {
		// not exist in visited
		temp_visited[url] = *id

		// create Node
		// fmt.Println("========= NODE CREATED =========")
		*temp_nodes = append(*temp_nodes, Node{Id: *id, Level: depth, Label: url[30:], Color: colorlist[depth], Group: depth})
		*id++
	}

	penentu := false
	for key := range graph[url] {
		x := false
		// create edges
		// fmt.Println("url: ", key)

		// time.Sleep(1 * time.Second)
		// traverse
		x = ConvertToVisualizer(id, depth+1, temp_nodes, temp_edges, temp_visited, graph, key, start, maxdepth)
		if x {
			// create edge
			var from_int int = temp_visited[key]
			var to_int int = temp_visited[url]
			*temp_edges = append(*temp_edges, Edge{From: from_int, To: to_int})
			penentu = true
		}
		if key == start && x {
			// fmt.Println("===================== EDGE TO JOKOWI CREATED +++++++++++++++++")
			// fmt.Println(key)
			var from_int int = temp_visited[key]
			var to_int int = temp_visited[url]
			fmt.Println(key, " -> ", url)
			fmt.Println(from_int, " -> ", to_int)
		}
	}

	return penentu
}

func ConvertToVisualizerIDS(id *int, temp_nodes *[]Node, temp_edges *[]Edge, temp_visited map[string]int, data [][]string, start string) {
	for idx1 := range data {
		for idx2 := range data[idx1] {
			_, err := temp_visited[data[idx1][idx2]]

			if !err {
				// create node

				temp_visited[data[idx1][idx2]] = *id

				*temp_nodes = append(*temp_nodes, Node{Id: *id, Level: idx2 + 1, Label: data[idx1][idx2][30:], Color: colorlist[idx2+1]})
				*id++
			}

			// create edges
			if idx2 == 0 {
				*temp_edges = append(*temp_edges, Edge{From: temp_visited[start], To: temp_visited[data[idx1][idx2]]})
			} else {
				*temp_edges = append(*temp_edges, Edge{From: temp_visited[data[idx1][idx2-1]], To: temp_visited[data[idx1][idx2]]})
			}
		}
	}
}

func ConvertToVisualizerHandler(start string, end string, temp map[string]map[string]bool, maxdepth int, ids_data [][]string, algorithm string) ([]Node, []Edge) {

	var temp_nodes []Node
	var temp_edges []Edge

	id := 0
	var temp_visited = make(map[string]int)
	temp_visited[start] = id

	if algorithm == "BFS" {
		var temp_has_edges = make(map[int]bool)
		var temp_has_nodes []Node

		temp_nodes = append(temp_nodes, Node{Id: id, Level: maxdepth + 1, Label: start[30:], Color: colorlist[maxdepth+1]})
		id++
		ConvertToVisualizer(&id, 0, &temp_nodes, &temp_edges, temp_visited, temp, end, start, maxdepth)

		for idx := range temp_edges {
			temp_has_edges[temp_edges[idx].From] = true
			temp_has_edges[temp_edges[idx].To] = true
		}

		for idx := range temp_nodes {
			val := temp_has_edges[temp_nodes[idx].Id]
			if val {
				temp_has_nodes = append(temp_has_nodes, temp_nodes[idx])
			}
		}

		temp_nodes = temp_has_nodes
	} else if algorithm == "IDS" {
		temp_nodes = append(temp_nodes, Node{Id: id, Level: 0, Label: start[30:], Color: colorlist[0]})
		id++
		ConvertToVisualizerIDS(&id, &temp_nodes, &temp_edges, temp_visited, ids_data, start)
	}

	return temp_nodes, temp_edges
}
